//так как у нас есть ограничение на длину n - 100 цифр то их сумма максимум 900
//значит сумма квадратов каждой цифры максимум 8100
//каждая цифра имеет значение 1-9 (0 не увеличивает результат но занимает место)
//тогда s1 и s2 могут быть изменены из предыдущих s1-k и s2-k * k
//где k - число от 1 до 9 (начальное)
//тогда наша функция перехода между состояниями, которая показывает что сумма каждой цифры это i, а сумма квадратов каждой цифры
//это минимальное количество цифр используемое j
//dp[i][j]=min(dp[i][j],dp[i−k][j−k∗k]+1)
//фактически когда происходит переход между состояними k показывает значение каждого бита, поэтому целесообразно сделать
//массив pre_init в котором записано, что сумма каждой цифры = i, сумма каждого квадрата - max j

using namespace std;
#include <iostream>
int dp[1000][10000];
int pre_init[1000][10000];

void Pre_init()
{
	for (int i = 0; i <= 900; i++)
	{
		for (int j = 0; j <= 8100; j++)
		{
			dp[i][j] = 101;
		}
			
	}

	dp[0][0] = 0;
	for (int i = 1; i <= 900; i++)
	{
		for (int j = 1; j <= 8100; j++)
		{
			for (int k = 1; (k <= 9) && (k <= i) && (k * k <= j); k++)
			{
				if ((i - k < 0) ||  (j - k * k < 0))
					break;

				if (dp[i][j] > dp[i - k][j - k * k] + 1)
				{
					dp[i][j] = dp[i - k][j - k * k] + 1;
					pre_init[i][j] = k;
				}
			}
		}
	}
}

int main()
{
	Pre_init();
	int s1, s2;
	int T;
	cin >> T;
	while (T--)
	{
		
		cin >> s1;
		cin >> s2;

		if (s1 > s2 || s1 > 900 || s2 > 8100 || dp[s1][s2] > 100)
		{
			cout << "No solution" << endl;
			continue;
		}
		int t;
		while (dp[s1][s2])
		{
			t = pre_init[s1][s2];
			cout << t;
			
			s1 -= t;
			s2 -= t * t;
		}
		cout << endl;
	}
	return 0;
}
